---
title: "Analyzing Business Relations & Documents"
subtitle: "Text as Data"
author: "Prof. Dr. Jörg Schoder"
institute: "FFHS" 
date: "`r Sys.Date()`"
bibliography: ../../lit/my_bib.bib
reference-section-title: Quellenverzeichnis
output:
  xaringan::moon_reader:
    self_contained: true
    css: 
         - default
         - ../../css/ffhs-theme_js.css
         - xaringan-themer.css
    includes:
      after_body: ../../css/insert-logo.html
    lib_dir: ../../libs
    nature:
      slideNumberFormat: "%current%/%total%"
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    seal: false
    

    
---
class: title-slide

```{r xaringan-themer, include=FALSE}
library(xaringanthemer)
style_xaringan(text_color = "#d50006",inverse_text_color = "#FFFFFF",inverse_background_color = "#d50006", title_slide_background_color = "#d50006",header_background_color = "#d50006",header_color = "#FFFFFF",header_h1_font_size = "32px",
  header_h2_font_size = "26px",link_color="#502479",
  header_h3_font_size = "20px",text_slide_number_color = "#d50006",text_slide_number_font_size = "0.5em")
```

```{r xaringanExtra, echo=FALSE}
xaringanExtra::use_progress_bar(color = "#d50006", location = "bottom")
xaringanExtra::use_xaringan_extra(c("tile_view","scribble","panelset","tachyons"))
xaringanExtra::style_panelset_tabs(font_family = "inherit")
#xaringanExtra::use_search(show_icon = TRUE)
#weitere: "share_again","animate_css", "webcam","freezeframe","clipboard","fit_screen","extra-styles" 
xaringanExtra::use_editable(expires = 1)
xaringanExtra::use_freezeframe(trigger = "hover")
``` 

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
library(latex2exp)
library(fontawesome)
library(emo)
source(xfun::from_root("lit","helper.R"))
library(RefManageR)
BibOptions(check.entries = FALSE, 
           bib.style = "authoryear", 
           style = "markdown",
           dashed = TRUE)
file.name <- system.file("Bib", 
                         "my_bib.bib", 
                         package = "RefManageR")
bib <- ReadBib(xfun::from_root("lit","my_bib.bib"))
```

# ER018 - Analyzing Business Relations & Documents

## PVA1

### Arbeiten mit Zeichenketten (strings)

 

<br>
<br>
<br>
<br>
<br>
<br>
<br>
### FS 2024
<br>
### Prof. Dr. Jörg Schoder
.mycontacts[
`r fa('github')` @FFHS-EconomicResearch
`r fa('linkedin')` @jfschoder
]


---
layout: true

<div class="my-footer"></div>       

<div style="position: absolute;left:400px;bottom:10px;font-size:9px">`r fa('creative-commons')``r rmarkdown::metadata$author`</div>


---
name: agenda
class: left

.blockquote[Agenda]

## Arbeiten mit Zeichenketten (strings)

* (Sehr kurze) Einführung in R-Objekte

* Zeichenketten in Base-R und das stringr-Paket

* Regelhafte Ausdrücke (regular expressions)

* Fortgeschrittene reguläre Ausdrücke
 

---
class: left

.blockquote[Intro R-Objekte]

## R als objektorientierte Sprache

* Objekte lassen sich in Klassen einteilen
  * tibbles, data.frames
  * Vektoren
  * Funktionen

--
* Objekte sind vektorbasiert

--
* Variablentypen

--
  * logisch (`logical`)

--
  * numerisch
      * `integer`
      * `double`
--
  * kategorial
      * `character` (Zeichenketten, engl. strings)
      * `factor`


`r fa('circle-right')` vgl. ausführlicher `r Citet(bib,"wickham_r_2023")`, Kapitel 12ff.

???

* logical: binäre Logik (true vs. false)
* numerisch: integer (ganze Zahlen), double (Doppelgleitkommazahlen)
* kategoriale Daten
  * strings (Zeichenketten)
  * factors für überschaubar viele Ausprägungen, die nich alphanumerisch geordnet werden sollen



---
class: inverse, center, middle

## Zeichenketten in Base-R


.blockquote[strings erzeugen]

.blockquote[strings verknüpfen]

.blockquote[strings zerlegen]


---
class: left

.blockquote[strings erzeugen]

## Eingabe mit Anführungzeichen

* Einfache Anführungszeichen

```{r}
"hoi!"
```

* Doppelte Anführungszeichen

```{r}
'hoi!'
```

* Problem: verschachtelte Anführungszeichen

```{r}
#| error: true
# Ich habe "hoi!" gesagt
"Ich habe "hoi!" gesagt."
``` 



---
class: left

.blockquote[strings erzeugen]

## Escape-Sequenz

* Verschachtelte Anführungszeichen: 
  * Variante 1 (`'`)

```{r}
'Ich habe "hoi!" gesagt.'
```
  
  * Variante 2 `\"` (Escape Sequenz!)
```{r}
"Ich habe \"hoi!\" gesagt."
```



---
class: left

.blockquote[strings erzeugen]

## Weitere Anwendungsfälle für Escape Sequenzen

* Neue Zeile: `\n` 

```{r}
"Mit dem Pfeil, dem Bogen
Durch Gebirg und Tal
Kommt der Schütz gezogen
Früh am Morgenstrahl."
```
* Unicode-Symbole ([Unicode-Chart](https://www.unicode.org/charts/)):
  * 8 Hexcode-Symbole: `\U`
  * 8 Hexcode-Symbole: `\u`

 


???

Escape sequences
You might have been surprised at the output from the last part of the last exercise. How did you get two lines from one string, and how did you get that little globe? The key is the \.

A sequence in a string that starts with a \ is called an escape sequence and allows us to include special characters in our strings. You saw one escape sequence in the first exercise: \" is used to denote a double quote.

In "hello\n\U1F30D" there are two escape sequences: \n gives a newline, and \U followed by up to 8 hex digits sequence denotes a particular Unicode character.

Unicode is a standard for representing characters that might not be on your keyboard. Each available character has a Unicode code point: a number that uniquely identifies it. These code points are generally written in hex notation, that is, using base 16 and the digits 0-9 and A-F. You can find the code point for a particular character by looking up a code chart. If you only need four digits for the codepoint, an alternative escape sequence is \u.

When R comes across a `\` it assumes you are starting an escape, so if you actually need a backslash in your string you'll need the sequence `\\`.


---
class: left

## Zahlenformate

.pull-left[
* `format()`: fix vs. wissenschaftlich
```{r}
x <- pi
x
```
]
--
.pull-right[
<br>

```{r}
format(x, scientific = TRUE)
```
]
--
.pull-left[
* `as.character()`

```{r}
as.character(x)
```
]


???

wissenschaftlich: $3,1415*10^0$


---
class: left

.blockquote[strings verknüpfen]

## `paste()`-Funktion

```{r}
hopp <- paste("H","O","P","P")
hopp
```

```{r}
paste("H","O","P","P", sep = "-")
```

```{r}
paste(c("Hey","Ach","Mach"), "Du")
```
---
class: left

.blockquote[strings verknüpfen]

## Beispiel: Old MacDonald...

.panelset[
.panel[.panel-name[Funktion definieren]
```{r}
old_mac <- function(animal, animal_goes){
              eieio <- paste("E", "I", "E", "I", "O", sep = "-")
              old_mac <- "Old MacDonald had a farm"
              writeLines(c(
              old_mac,
              eieio,
              paste("And on his farm he had a", animal),
              eieio,
              paste(c("Here", "There", "Everywhere"), "a",
              c(animal_goes, animal_goes,
              paste(rep(animal_goes, 2), collapse = "-")),
              collapse = ", "),
              old_mac,
              eieio))
              }
```
.quellePanURL[Quelle: [C. Wickham, datacamp](https://app.datacamp.com/learn/courses/string-manipulation-with-stringr-in-r).]
]
.panel[.panel-name[Beispiel 1]
```{r}
old_mac("cow","moo")

```
]
.panel[.panel-name[Beispiel 2]
```{r}
old_mac("dog","wolf")

```
]
]


---
class: left

.blockquote[strings zerlegen]

## `strsplit()`-Funktion


.panelset[
.panel[.panel-name[Beispiele]
```{r}
strsplit(hopp,split = " ")
```
`r fa('exclamation-circle')` Output ist eine Liste.
```{r}
test_dates<-c("24-03-2024","25-03-2024","26-03-2024","27-03-2024")
date_split <- strsplit(test_dates, split = "-")
class(date_split)
```

]
.panel[.panel-name[Listen]

* Anzahl Listen und Anzahl Elemente im ersten Teilobjekt

```{r}
length(date_split)
length(date_split[[1]])

```

* Inhalt des ersten Teilobjekts der Liste

```{r}
date_split[1]
```
]
]

???

* arbeiten mit Listen ist eher kompliziert, daher empfiehlt es sich...

* ...Zerlegungen nicht mit der Base-R-Funktion strsplit() zu machen

* sondern auf tidyverse-Pakete zurückzugreifen
  * allgemein: stringr-Paket
  * speziell für Datumsangeben: lubridate
  
* bevor wir das stringr-Paket ausführlicher anschauen, ein kurzer Exkurs ins
lubridate-Paket


---
class: inverse, center, middle

## strings verarbeiten im tidyverse

.blockquote[Exkurs: lubridate für Datumsangaben]

.blockquote[stringr-Paket]

.blockquote[Beispiel: Vornamenhitparade CH]


---
class: left

.blockquote[Exkurs: lubridate für Datumsangaben]

## Verarbeitung von Datumsangaben im tidyverse

* **lubridate**-Bibliothek ist Teil des **tidyverse**-Metapakets

* Datumsobjekt erzeugen:

```{r}
#| message: false
#| warning: false
library(tidyverse)
dates <- dmy(test_dates) # transformieren in Date-Objekt
```

--
* Zerlegung in Tag, Monat, Jahr

.pull-left[
```{r}
#| output-details: false
day(dates)
year(dates)
```
]
--
.pull-right[
```{r}
#| output-details: false
month(dates)
month(dates,label = TRUE)
```

]

???

* **lubridate**-Paket  mit speziellen Funktionen für Datumsangaben




---
class: left 

.blockquote[stringr-Paket]

## Verarbeitung von Zeichenketten (strings) im **tidyverse**

.panelset[
.panel[.panel-name[Kurzüberblick]

* Aufbauend auf stringi

* Wird mit dem **tidyverse**-Metapaket automatisch geladen

* Als Teil des **tidyverse** leistungsstark und leicht zu erlernen

* Prägnant und konsistent: Alle Funktionen...

  * beginnen mit `str_`

  * nutzen als erstes Argument (Input) einen Vektor von Strings 

* Ergebnisse werden in `tibble`-Objekten gespeichert und können direkt in **Pipes** weiterverarbeitet werden.
]
.panel[.panel-name[Vignette]
```{r}
#| echo: false
knitr::include_url('https://stringr.tidyverse.org/',height = "400px")
```
]
]



---
class: left

.blockquote[Beispiel: Vornamenhitparade CH]

## Datenbasis 


.panelset[
.panel[.panel-name[Datenquelle]
```{r}
#| echo: false
#| out-width: '70%'
#| fig-align: 'center'
knitr::include_graphics(xfun::from_root('img','PVA1','BFS_20240408.png'))
```

.quellePanURL[`r fa('link')` [Download Rohdaten](https://www.bfs.admin.ch/bfs/de/home/statistiken/bevoelkerung/geburten-todesfaelle/vornamen-neugeborene.assetdetail.26565506.html).]

]
.panel[.panel-name[Datenimport]

* Aufbereitete Daten importieren

```{r}
my_in_file <- "BabynamesCH_(BFS_2024).rds"
tbl_babynames <- read_rds(xfun::from_root('data','tidy',my_in_file))
```

* Anzahl Beobachtungen

```{r}
tbl_babynames %>% 
            count()
```

]
.panel[.panel-name[Daten]
* Einblick in die Tabelle (long-Format)

```{r}
head(tbl_babynames,7)
```

]
]






---
class: left

.blockquote[Beispiel: Vornamenhitparade CH]

## Länge der Vornamen mit `str_length()`

```{r}
#| message: false
tbl_babynames %>% 
      group_by(year,gender) %>% 
      summarize(min=min(str_length(Vorname)),
                max=max(str_length(Vorname)),
                schnitt=mean(str_length(Vorname))) %>% head()
```

???


str_length() gibt die Länge einer Zeichenfolge zurück, das heißt, die Anzahl der Zeichen in der Zeichenfolge.
Beispiel: str_length("banana") würde 6 zurückgeben, da "banana" sechs Zeichen lang ist.

---
class: left

.blockquote[Beispiel: Vornamenhitparade CH]

## Anzahl Zeichen in Vornamen mit `str_count()`

.panelset[
.panel[.panel-name[Einfach]
```{r}
tbl_babynames %>% 
      mutate(n_zeichen = str_count(Vorname)) %>% 
      head(5)
```
]
.panel[.panel-name[Muster]
```{r}
tbl_babynames %>% 
      mutate(n_zeichen = str_count(Vorname, "m")) %>% 
      head(5)
```
]
]

`r fa('exclamation-circle')` `r fa('r-project')` ist "case-sensitive" (`r fa('circle-right')` Mia)

???

* Zahl der Zeichen im Vornamen kann auch mit `str_count()` ermittelt werden

* darüber hinaus bietet `str_count()` die Möglichkeit zum zählen der Anzahl der Vorkommen eines bestimmten **Musters** in einer Zeichenfolge.
Sie geben das Muster an, nach dem gesucht werden soll, und die Funktion gibt die Anzahl der Vorkommen dieses Musters in jeder Zeichenfolge zurück.
Wenn das Muster nicht gefunden wird, gibt str_count() 0 zurück.
Beispiel: str_count("banana", "a") würde 3 zurückgeben, da das Muster "a" drei Mal in "banana" vorkommt.

---
class: left

.blockquote[Beispiel: Vornamenhitparade CH]

## Teile von Vornamen extrahieren mit `str_sub()`


.panelset[
.panel[.panel-name[Erste 3 Buchstaben]
```{r}
tbl_babynames %>% 
  mutate(erste3 = str_sub(Vorname, 1, 3)) %>% 
  head()
```
]
.panel[.panel-name[Letzte 3 Buchstaben]
```{r}
tbl_babynames %>% 
  mutate(letzte3 = str_sub(Vorname, -3, -1)) %>% 
  head()
```
]
]


???

str_sub():

str_sub() wird verwendet, um Teilzeichenfolgen aus einer Zeichenfolge zu extrahieren.
Sie müssen Start- und Endindizes angeben, um den Teil der Zeichenfolge zu definieren, den Sie extrahieren möchten.
Das Ergebnis ist eine Teilzeichenfolge mit der Länge, die durch die angegebenen Start- und Endindizes definiert ist.
str_subset():

str_subset() wird verwendet, um eine Teilmenge von Zeichenfolgen zu extrahieren, die ein bestimmtes Muster erfüllen.
Sie müssen das Muster angeben, nach dem Sie suchen möchten.
Das Ergebnis ist eine Teilmenge der ursprünglichen Zeichenfolgen, die das angegebene Muster erfüllen.



---
class: left

.blockquote[Beispiel: Vornamenhitparade CH]

## Teile von Vornamen extrahieren mit `str_subset()`

```{r}
tbl_babynames %>%
  reframe(muster = str_subset(Vorname, pattern = "anna"))
```




---
class: left

.blockquote[Beispiel: Vornamenhitparade CH]

## Teile von Vornamen extrahieren mit `str_extract()`


.panelset[
.panel[.panel-name[str_extract]

* `str_extract()` prüft die Zeichenfolgen auf das Muster...

* ...und gibt für Fälle, in denen das Muster nicht vorkommt "NA" aus

```{r}
tbl_babynames %>%
  reframe(muster = str_extract(Vorname, pattern = "anna")) %>% 
  head(3)
```

]
.panel[.panel-name[Auszählen]
```{r}
tbl_babynames %>%
  reframe(muster = str_extract(Vorname, pattern = "anna")) %>% 
  summarize(fehlende = sum(is.na(muster)),
            nicht_fehlende = sum(!is.na(muster)))
```

]
.panel[.panel-name[Unterschied]

* `str_subset()` gibt gesamte Zeichenkette aus, `str_extract()` nur das Muster

```{r}
tbl_babynames %>%
  reframe(muster = str_extract(Vorname, pattern = "anna")) %>% 
  filter(!is.na(muster)) %>% 
  head(4)
```
]
]



???

* Während `str_subset()` die gesamte Zeichenfolge ausgibt, die das Muster enthält...

* ...gibt `str_extract()` nur die gesuchte Zeichenkette aus


str_extract() ist ähnlich wie str_subset() in dem Sinne, dass es verwendet wird, um Zeichenfolgen zu extrahieren, die ein bestimmtes Muster erfüllen. Allerdings gibt es einen wesentlichen Unterschied:

str_subset(): Gibt die gesamte Teilzeichenfolge zurück, die das Muster erfüllt.
str_extract(): Gibt den ersten Teil der Zeichenfolge zurück, der das Muster erfüllt.




---
class: left

.blockquote[Beispiel: Vornamenhitparade CH]

## Muster in Vornamen finden mit `str_detect()`


.panelset[
.panel[.panel-name[einfach]
* Vornamen, die "tz" enthalten

```{r}
tbl_babynames  %>% 
      filter(str_detect(Vorname, pattern = "tz")) 
```

]
.panel[.panel-name[kombiniert]

* Mädchennamen, die "sa" enthalten und mit "L" beginnen

```{r}
tbl_babynames %>%
  filter(str_detect(Vorname, pattern = "sa")) %>%
  mutate(muster = str_detect(Vorname, pattern = "L")) %>% 
  head(5)

```

]
]





---
class: left

.blockquote[Beispiel: Vornamenhitparade CH]

## Zeichenketten aufteilen `str_split()`

.panelset[
.panel[.panel-name[Voller Name]
```{r}
tbl_tmp <- tbl_babynames %>%
                mutate(Name = paste("Odermatt,", Vorname)) %>% 
                select(Name,gender,year,rank,count)
head(tbl_tmp)
```

]
.panel[.panel-name[Aufsplitten]
```{r}
tbl_tmp %>%
    mutate(Nachname = str_split(Name, pattern = ", ", n = 2) %>% map_chr(1),
         Vorname = str_split(Name, pattern = ", ", n = 2) %>% map_chr(2)) %>% 
    head()
```
]
]



---
class: left

.blockquote[Beispiel: Vornamenhitparade CH]

## Zeichenketten modifizieren `str_replace()`

* (Sehr schmutzige) Alternative zu `str_split()`

* "Überschreiben" der Zeichenkette "Odermatt, " mit leerer Zeichenfolge ("") 

```{r}
tbl_tmp %>%
    mutate(Vorname = str_replace(Name, pattern = "Odermatt,", "") %>% str_trim()) %>% 
  head()
```
???

`str_trim()` muss verwendet werden, um führende und abschließende Leerzeichen zu entfernen, bevor die Daten ausgegeben werden können.


---
class: left

.blockquote[Beispiel: Vornamenhitparade CH]

## Typische Anwendungen für `str_replace()`


```{r}
test_dates
```

```{r}
test_dates %>% 
      str_replace(pattern="-",".")
```
```{r}
test_dates %>% 
      str_replace_all(pattern="-",".")
```

---
class: left

.blockquote[Beispiel: Vornamenhitparade CH]

## Ausblick: Quantitative Textanalyse


.panelset[
.panel[.panel-name[Plot]
```{r}
#| echo: false
#| out-width: '55%'
#| fig-align: 'center'
anfangsbuchstabe <- tbl_babynames %>%
                        mutate(first_letter = substr(Vorname, 1, 1)) %>%
                        group_by(year,gender, first_letter) %>%
                        count()
anfangsbuchstabe %>%
  mutate(gender = factor(gender, levels = c("boys", "girls"))) %>%
  group_by(gender,year) %>%
  arrange(desc(n)) %>%
  slice_max(n=10,order_by = n) %>%
  ggplot(aes(x=first_letter,y=n,fill=fct_reorder(gender,n))) +
     geom_col(position = 'dodge') +
     facet_wrap(~fct_rev(year),scales = "free_x") +
     scale_fill_discrete(labels = c("girls" = "Mädchen", "boys" = "Knaben")) +
     labs(x='Anfangsbuchstabe',y='absolute Häufigkeit') + theme_light() +
     theme(legend.position = "bottom", legend.title = element_blank())  
```
]
.panel[.panel-name[Code]
```{r}
#| eval: false
anfangsbuchstabe <- tbl_babynames %>%
                        mutate(first_letter = substr(Vorname, 1, 1)) %>%
                        group_by(year,gender, first_letter) %>%
                        count()

anfangsbuchstabe %>%
  mutate(gender = factor(gender, levels = c("boys", "girls"))) %>%
  group_by(gender,year) %>%
  arrange(desc(n)) %>%
  slice_max(n=10,order_by = n) %>%
  ggplot(aes(x=first_letter,y=n,fill=fct_reorder(gender,n))) +
     geom_col(position = 'dodge') +
     facet_wrap(~fct_rev(year),scales = "free_x") +
     scale_fill_discrete(labels = c("girls" = "Mädchen", "boys" = "Knaben")) +
     labs(x='Anfangsbuchstabe',y='absolute Häufigkeit') + theme_light() +
     theme(legend.position = "bottom", legend.title = element_blank())  
```
]

]




---
class: inverse, center, middle


## Regelhafte Ausdrücke

.blockquote[Regelhafte Ausdrücke mit dem rebus-Paket]

.blockquote[Abwechselnde Zeichenfolgen (Alternations)]

.blockquote[Zeichenklassen (Character classes)]

.blockquote[Wiederholungen]

.blockquote[Abkürzungen]


---
class: left

.blockquote[Regelhafte Ausdrücke mit dem rebus-Paket]

## Regelhafte Ausdrücke 

???

* regular expressions (regexp)




---
class: left

.blockquote[Regelhafte Ausdrücke mit dem rebus-Paket]

## Regelhafte Ausdrücke

* Übersicht

| Muster               | Regelmäßiger Ausdruck |   rebus    |
|----------------------|:---------------------:|:----------:|
| Beginn eines strings |          `^`          |  `START`   |
| Ende eines strings   |          `$`          |   `END`    |
| Einzelne Symbole     |          `.`          | `ANY_CHAR` |
| "Belegte" Symbole (`.`,`^`,`$`)|    `\.`,`\^`,`\$` | `DOT`,`CARAT`, `DOLLAR`|


* Besondere Muster regelhafte Ausdrücke
  * Alternative Zeichenfolgen (Alternations)
  * Zeichenklassen (character classes)
  * Wiederholungen



---
class: left

.blockquote[Alternative Zeichenfolgen]

## Unterschiedliche Kombinationen von Zeichenfolgen

`(winter|sommer)`

```{r}
#| echo: true
#| message: false
#| warning: false
library(stringr)
library(rebus)
or("Winter","Sommer")
```
```{r}
#| echo: true
str_view(c("Sommer-Hitze","Traum-Winter","Traumwinter"),
  pattern = or("[Ww]inter","[Ss]ommer"),
  match=TRUE,html=TRUE)
```
???

* Obs! Die erste Ausgabe unterscheidet sich leicht von der Eingabe: rebus ergänzt um `?:`, um anzuzeigen, dass es sich um eine "nicht-einfangende Gruppe" von Zeichen (non-capturing group) handelt. Dazu später mehr


---
class: left

.blockquote[Zeichenklassen (character classes)]

## Identifikation von (definierten) Symbolen

.pull-left[
```{r}
char_class("Aa")
```


```{r}
str_view(c("Frankfurt","Freiheit","Effekt","Schifffahrt"),
          pattern = char_class("Ff"),html=TRUE
)
```
]
--
.pull-right[
```{r}
negated_char_class("Ff")
```

```{r}
str_view(c("Frankfurt","Freiheit","Effekt","Schifffahrt"),
          pattern = negated_char_class("Ff"),html=TRUE
)
```

]

???

* `char_class()` hilft alle Symbole zu finden
* Mit `negated_char_class()` können alle Symbole "außer" die angebebenen identifiziert werden.
  * dies wird in rebus durch das Carat `^`-Symbol innerhalb der eckigen Klammer angezeigt
  


<!-- --- -->
<!-- class: left -->

<!-- ## Besonderheiten bei Verwendung von Zeichenklassen -->

<!-- .pull-left[ -->

<!-- * Minuszeichen -->

<!-- ```{r} -->
<!-- str_view(c("allgemein","Aaron","Sommer-Hitze"), -->
<!--          pattern = char_class("Aa-"),html=TRUE -->
<!--          ) -->
<!-- ``` -->
<!-- ] -->

<!-- .pull-right[ -->

<!-- <br> -->

<!-- ```{r} -->
<!-- str_view(c("allgemein","Aaron","Sommer-Hitze"), -->
<!--          pattern = char_class("-Aa"),html=TRUE -->
<!--          ) -->
<!-- ``` -->
<!-- ] -->

<!-- ??? -->


<!-- * **Wichtig:** innerhalb von `char_class()` müssen spezielle Symbole wie bspw. `^` oder `$` **nicht** "maskiert" werden. Ein Punkt `.` kann also direkt eingefügt werden. -->
<!--   * Ausnahme: Das Minuszeichen. Wenn es in der `char_class()`-Funktion verwendet werden soll, dann sollte es **an erster Stelle** kommen, also bspw. `char_class("-Aa")` -->


---
class: left

.blockquote[Wiederholungen]

## Zeichenketten mit mehreren gleichartigen Symbolen/Mustern

* Übersicht

| Muster               | Regelmäßiger Ausdruck |   rebus    |
|----------------------|:---------------------:|:----------:|
| Optional             |          `?`          |  `optional()` |
| Null oder mehr       |          `*`          |   `zero_or_more()` |
| Eins oder mehr     |          `+`          | `one_or_more()` |
| Zwischen m- und n-mal |    `{m,n}` | `repeated()`|

* Beispiel

```{r}
str_view(c("Frankfurt","Freiheit","Effekt","Schifffahrt"),
         pattern = repeated("Ff",2,3),html=TRUE
         )

```



---
class: left

.blockquote[Abkürzungen]

## Abgekürzte Eingabe regelhafter Ausdrücke

.pull-left[

* $-Symbol und Ziffer(n):

```{r}
DOLLAR %R% char_class("0123456789")
```
]
--
.pull-right[
* Eine Ziffer:

```{r}
char_class("0-9")
```

]
--


.pull-left[
* Kleinbuchstaben

```{r}
char_class("a-z")
```

]
--
.pull-right[

* Großbuchstaben

```{r}
char_class("A-Z")
```


]


---
class: left

.blockquote[Abkürzungen]

## Abgekürzte Eingabe regelhafter Ausdrücke

.pull-left[

* Ziffern

```{r}
DGT
```

]
--

.pull-right[
<br>
```{r}
char_class("0-9")
```
]
--
.pull-left[

* Buchstaben

```{r}
WRD
```
]
--
.pull-right[
<br>
```{r}
char_class("a-zA-Z0-0_")
```
]
--
.pull-left[
* Leerzeichen (Whitespace)

```{r}
SPC
```

]


---
class: inverse, center, middle

## Fortgeschrittene regelhafte Ausdrücke

.blockquote[Erfassung (Capturing)]

.blockquote[Rückbezüge (Backreferences)]

.blockquote[Mustererkennung mit Unicode]

---
class: left

.blockquote[Erfassung (Capturing)]

##  Gruppierung von Teilmustern

* Dient der *Gruppierung von Teilen* von Mustern
* Erfasste Teile (von Mustern) können in darauffolgenden Schritten referenziert werden.


.pull-left[
```{r}
ANY_CHAR %R% "a"
```
]
--
.pull-right[
```{r}
str_extract(c("Fakten","Katzen"),
            pattern=ANY_CHAR %R% "a")
```
]
--



.pull-left[

* Erfasste Teile (*captured groups*) werden in regulären Ausdrücken durch `()` angezeigt/eingegeben: 
```{r}
capture(ANY_CHAR) %R% "a"
```
]
--
.pull-right[
* Capturing führt vordergründig (!) zum selben Ergebnis:
```{r}
str_extract(c("Fakten","Katzen"),
            capture(ANY_CHAR) %R% "a")
```
]

???

* Capturing ändert nicht das Muster, das abgeglichen wird, entsprechend führt es auch zum selben Ergebnis
* Aber: capturing zeigt an, dass wir (in darauffolgenden Schritten) etwas mit dem erfassten Muster machen wollen


---
class: left

.blockquote[Erfassung (Capturing)]

##  Verwendung erfasster Teilmuster

* Verwendung in `str_match()` liefert eine Matrix, wobei die...
  * ...erste Spalte  dem Ergebnis von `str_extract()` entspricht.
  * ...zweite Spalte  nur den erfassten Teil des Musters enthält.

* Beispiel

```{r}
str_match(c("Fakten","Katze"), pattern=capture(ANY_CHAR) %R% "a")
```

???

* Verwendung in `str_match()` liefert eine Matrix
  * erste Spalte entspricht dem Ergebnis von `str_extract()` **mit dem exakten Match**
  * die zweite Spalte enthält dagegen nur den erfassten Teil des Musters in der captured group


---
class: left

.blockquote[Erfassung (Capturing)]

##  Anwendungsbeispiel mit erfassten Gruppen

* Beispiel: Dollar-Beträge unter 100$

```{r}
muster <- DOLLAR %R% DGT %R% optional(DGT) %R% DOT %R% dgt(2)
str_view(c("$7.70","$27.00"),pattern = muster)
```

* Nutzung erfasster Teilmuster zur getrennten Extraktion von Dollar- und Cent-Beträgen:

```{r}
cap_muster <- DOLLAR %R% capture(DGT %R% optional(DGT)) %R% DOT %R% capture(dgt(2))
str_match(c("$7.70","$27.00"), pattern = cap_muster)
```



???

* Obs! capture-Funktion wird zweimal verwendet:
  * einmal um die Vorkommastelle(n) und 
  * einmal um die Nachkommastellen



---
class: left

.blockquote[Rückbezüge (Backreferences)]

## Verweis auf erfasste Teile von Mustern

```{r}
REF1
```

```{r}
REF2
```



---
class: left

.blockquote[Mustererkennung mit Unicode]

## Unicode




---
class: inverse,center,middle

# Wir brauchen eine Pause.

---

background-image: url("http://bit.ly/cs631-donkey")
background-size: 80%





---
class: left

## Quellenverzeichnis

.ref-slide[
```{r, results='asis', echo=FALSE, warning=FALSE}
PrintBibliography(bib)
```
]
